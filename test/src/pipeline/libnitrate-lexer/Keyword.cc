#include <gtest/gtest.h>

#include <pipeline/libnitrate-lexer/LexicalCase.hh>

using namespace ncc::lex;

///============================================================================///
/// LANGUAGE KEYWORDS
TEST_CASE(Keyword, Parse, 0, "scope", {Scope})
TEST_CASE(Keyword, Parse, 1, "pub", {Pub})
TEST_CASE(Keyword, Parse, 2, "sec", {Sec})
TEST_CASE(Keyword, Parse, 3, "pro", {Pro})
TEST_CASE(Keyword, Parse, 4, "import", {Import})
TEST_CASE(Keyword, Parse, 5, "type", {Type})
TEST_CASE(Keyword, Parse, 6, "let", {Let})
TEST_CASE(Keyword, Parse, 7, "var", {Var})
TEST_CASE(Keyword, Parse, 8, "const", {Const})
TEST_CASE(Keyword, Parse, 9, "static", {Static})
TEST_CASE(Keyword, Parse, 10, "struct", {Struct})
TEST_CASE(Keyword, Parse, 11, "region", {Region})
TEST_CASE(Keyword, Parse, 12, "group", {Group})
TEST_CASE(Keyword, Parse, 13, "class", {Class})
TEST_CASE(Keyword, Parse, 14, "union", {Union})
TEST_CASE(Keyword, Parse, 15, "opaque", {Opaque})
TEST_CASE(Keyword, Parse, 16, "enum", {Enum})
TEST_CASE(Keyword, Parse, 17, "__fstring", {__FString})
TEST_CASE(Keyword, Parse, 18, "fn", {Fn})
TEST_CASE(Keyword, Parse, 20, "safe", {Safe})
TEST_CASE(Keyword, Parse, 21, "unsafe", {Unsafe})
TEST_CASE(Keyword, Parse, 22, "pure", {Pure})
TEST_CASE(Keyword, Parse, 23, "impure", {Impure})
TEST_CASE(Keyword, Parse, 24, "quasi", {Quasi})
TEST_CASE(Keyword, Parse, 25, "retro", {Retro})
TEST_CASE(Keyword, Parse, 26, "inline", {Inline})
TEST_CASE(Keyword, Parse, 27, "foreign", {Foreign})
TEST_CASE(Keyword, Parse, 28, "promise", {Promise})
TEST_CASE(Keyword, Parse, 29, "if", {If})
TEST_CASE(Keyword, Parse, 30, "else", {Else})
TEST_CASE(Keyword, Parse, 31, "for", {For})
TEST_CASE(Keyword, Parse, 32, "while", {While})
TEST_CASE(Keyword, Parse, 33, "do", {Do})
TEST_CASE(Keyword, Parse, 34, "switch", {Switch})
TEST_CASE(Keyword, Parse, 35, "break", {Break})
TEST_CASE(Keyword, Parse, 36, "continue", {Continue})
TEST_CASE(Keyword, Parse, 37, "ret", {Return})
TEST_CASE(Keyword, Parse, 39, "foreach", {Foreach})
TEST_CASE(Keyword, Parse, 40, "try", {Try})
TEST_CASE(Keyword, Parse, 41, "catch", {Catch})
TEST_CASE(Keyword, Parse, 42, "throw", {Throw})
TEST_CASE(Keyword, Parse, 43, "async", {Async})
TEST_CASE(Keyword, Parse, 44, "await", {Await})
TEST_CASE(Keyword, Parse, 45, "__asm__", {__Asm__})
TEST_CASE(Keyword, Parse, 48, "true", {True})
TEST_CASE(Keyword, Parse, 49, "false", {False})
TEST_CASE(Keyword, Parse, 50, "escape_block", {EscapeBlock})
TEST_CASE(Keyword, Parse, 51, "unit_assert", {UnitAssert})

///============================================================================///
/// ADJACENT TO INTEGERS
TEST_CASE(Keyword, NextToInt, 0, "'abc'scope'hello'", {Token(Text, "abc"), Scope, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 1, "'abc'pub'hello'", {Token(Text, "abc"), Pub, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 2, "'abc'sec'hello'", {Token(Text, "abc"), Sec, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 3, "'abc'pro'hello'", {Token(Text, "abc"), Pro, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 4, "'abc'import'hello'", {Token(Text, "abc"), Import, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 5, "'abc'type'hello'", {Token(Text, "abc"), Type, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 6, "'abc'let'hello'", {Token(Text, "abc"), Let, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 7, "'abc'var'hello'", {Token(Text, "abc"), Var, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 8, "'abc'const'hello'", {Token(Text, "abc"), Const, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 9, "'abc'static'hello'", {Token(Text, "abc"), Static, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 10, "'abc'struct'hello'", {Token(Text, "abc"), Struct, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 11, "'abc'region'hello'", {Token(Text, "abc"), Region, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 12, "'abc'group'hello'", {Token(Text, "abc"), Group, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 13, "'abc'class'hello'", {Token(Text, "abc"), Class, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 14, "'abc'union'hello'", {Token(Text, "abc"), Union, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 15, "'abc'opaque'hello'", {Token(Text, "abc"), Opaque, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 16, "'abc'enum'hello'", {Token(Text, "abc"), Enum, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 17, "'abc'__fstring'hello'", {Token(Text, "abc"), __FString, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 18, "'abc'fn'hello'", {Token(Text, "abc"), Fn, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 19, "'abc'safe'hello'", {Token(Text, "abc"), Safe, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 20, "'abc'unsafe'hello'", {Token(Text, "abc"), Unsafe, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 21, "'abc'pure'hello'", {Token(Text, "abc"), Pure, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 22, "'abc'impure'hello'", {Token(Text, "abc"), Impure, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 23, "'abc'quasi'hello'", {Token(Text, "abc"), Quasi, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 24, "'abc'retro'hello'", {Token(Text, "abc"), Retro, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 25, "'abc'inline'hello'", {Token(Text, "abc"), Inline, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 26, "'abc'foreign'hello'", {Token(Text, "abc"), Foreign, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 27, "'abc'promise'hello'", {Token(Text, "abc"), Promise, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 28, "'abc'if'hello'", {Token(Text, "abc"), If, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 29, "'abc'else'hello'", {Token(Text, "abc"), Else, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 30, "'abc'for'hello'", {Token(Text, "abc"), For, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 31, "'abc'while'hello'", {Token(Text, "abc"), While, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 32, "'abc'do'hello'", {Token(Text, "abc"), Do, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 33, "'abc'switch'hello'", {Token(Text, "abc"), Switch, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 34, "'abc'break'hello'", {Token(Text, "abc"), Break, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 35, "'abc'continue'hello'", {Token(Text, "abc"), Continue, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 36, "'abc'ret'hello'", {Token(Text, "abc"), Return, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 38, "'abc'foreach'hello'", {Token(Text, "abc"), Foreach, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 39, "'abc'try'hello'", {Token(Text, "abc"), Try, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 40, "'abc'catch'hello'", {Token(Text, "abc"), Catch, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 41, "'abc'throw'hello'", {Token(Text, "abc"), Throw, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 42, "'abc'async'hello'", {Token(Text, "abc"), Async, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 43, "'abc'await'hello'", {Token(Text, "abc"), Await, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 44, "'abc'__asm__'hello'", {Token(Text, "abc"), __Asm__, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 47, "'abc'true'hello'", {Token(Text, "abc"), True, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 48, "'abc'false'hello'", {Token(Text, "abc"), False, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 49, "'abc'escape_block'hello'", {Token(Text, "abc"), EscapeBlock, Token(Text, "hello")})
TEST_CASE(Keyword, NextToInt, 50, "'abc'unit_assert'hello'", {Token(Text, "abc"), UnitAssert, Token(Text, "hello")})

///============================================================================///
/// ADJACENT TO PUNCTUATION
TEST_CASE(Keyword, NextToPunc, 0, "+scope:", {OpPlus, Scope, PuncColn})
TEST_CASE(Keyword, NextToPunc, 1, "+pub:", {OpPlus, Pub, PuncColn})
TEST_CASE(Keyword, NextToPunc, 2, "+sec:", {OpPlus, Sec, PuncColn})
TEST_CASE(Keyword, NextToPunc, 3, "+pro:", {OpPlus, Pro, PuncColn})
TEST_CASE(Keyword, NextToPunc, 4, "+import:", {OpPlus, Import, PuncColn})
TEST_CASE(Keyword, NextToPunc, 5, "+type:", {OpPlus, Type, PuncColn})
TEST_CASE(Keyword, NextToPunc, 6, "+let:", {OpPlus, Let, PuncColn})
TEST_CASE(Keyword, NextToPunc, 7, "+var:", {OpPlus, Var, PuncColn})
TEST_CASE(Keyword, NextToPunc, 8, "+const:", {OpPlus, Const, PuncColn})
TEST_CASE(Keyword, NextToPunc, 9, "+static:", {OpPlus, Static, PuncColn})
TEST_CASE(Keyword, NextToPunc, 10, "+struct:", {OpPlus, Struct, PuncColn})
TEST_CASE(Keyword, NextToPunc, 11, "+region:", {OpPlus, Region, PuncColn})
TEST_CASE(Keyword, NextToPunc, 12, "+group:", {OpPlus, Group, PuncColn})
TEST_CASE(Keyword, NextToPunc, 13, "+class:", {OpPlus, Class, PuncColn})
TEST_CASE(Keyword, NextToPunc, 14, "+union:", {OpPlus, Union, PuncColn})
TEST_CASE(Keyword, NextToPunc, 15, "+opaque:", {OpPlus, Opaque, PuncColn})
TEST_CASE(Keyword, NextToPunc, 16, "+enum:", {OpPlus, Enum, PuncColn})
TEST_CASE(Keyword, NextToPunc, 17, "+__fstring:", {OpPlus, __FString, PuncColn})
TEST_CASE(Keyword, NextToPunc, 18, "+fn:", {OpPlus, Fn, PuncColn})
TEST_CASE(Keyword, NextToPunc, 19, "+safe:", {OpPlus, Safe, PuncColn})
TEST_CASE(Keyword, NextToPunc, 20, "+unsafe:", {OpPlus, Unsafe, PuncColn})
TEST_CASE(Keyword, NextToPunc, 21, "+pure:", {OpPlus, Pure, PuncColn})
TEST_CASE(Keyword, NextToPunc, 22, "+impure:", {OpPlus, Impure, PuncColn})
TEST_CASE(Keyword, NextToPunc, 23, "+quasi:", {OpPlus, Quasi, PuncColn})
TEST_CASE(Keyword, NextToPunc, 24, "+retro:", {OpPlus, Retro, PuncColn})
TEST_CASE(Keyword, NextToPunc, 25, "+inline:", {OpPlus, Inline, PuncColn})
TEST_CASE(Keyword, NextToPunc, 26, "+foreign:", {OpPlus, Foreign, PuncColn})
TEST_CASE(Keyword, NextToPunc, 27, "+promise:", {OpPlus, Promise, PuncColn})
TEST_CASE(Keyword, NextToPunc, 28, "+if:", {OpPlus, If, PuncColn})
TEST_CASE(Keyword, NextToPunc, 29, "+else:", {OpPlus, Else, PuncColn})
TEST_CASE(Keyword, NextToPunc, 30, "+for:", {OpPlus, For, PuncColn})
TEST_CASE(Keyword, NextToPunc, 31, "+while:", {OpPlus, While, PuncColn})
TEST_CASE(Keyword, NextToPunc, 32, "+do:", {OpPlus, Do, PuncColn})
TEST_CASE(Keyword, NextToPunc, 33, "+switch:", {OpPlus, Switch, PuncColn})
TEST_CASE(Keyword, NextToPunc, 34, "+break:", {OpPlus, Break, PuncColn})
TEST_CASE(Keyword, NextToPunc, 35, "+continue:", {OpPlus, Continue, PuncColn})
TEST_CASE(Keyword, NextToPunc, 36, "+ret:", {OpPlus, Return, PuncColn})
TEST_CASE(Keyword, NextToPunc, 38, "+foreach:", {OpPlus, Foreach, PuncColn})
TEST_CASE(Keyword, NextToPunc, 39, "+try:", {OpPlus, Try, PuncColn})
TEST_CASE(Keyword, NextToPunc, 40, "+catch:", {OpPlus, Catch, PuncColn})
TEST_CASE(Keyword, NextToPunc, 41, "+throw:", {OpPlus, Throw, PuncColn})
TEST_CASE(Keyword, NextToPunc, 42, "+async:", {OpPlus, Async, PuncColn})
TEST_CASE(Keyword, NextToPunc, 43, "+await:", {OpPlus, Await, PuncColn})
TEST_CASE(Keyword, NextToPunc, 44, "+__asm__:", {OpPlus, __Asm__, PuncColn})
TEST_CASE(Keyword, NextToPunc, 47, "+true:", {OpPlus, True, PuncColn})
TEST_CASE(Keyword, NextToPunc, 48, "+false:", {OpPlus, False, PuncColn})
TEST_CASE(Keyword, NextToPunc, 49, "+escape_block:", {OpPlus, EscapeBlock, PuncColn})
TEST_CASE(Keyword, NextToPunc, 50, "+unit_assert:", {OpPlus, UnitAssert, PuncColn})
